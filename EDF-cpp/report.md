EDF实时调度算法
===================

设计思路
===================

首先我们读入所有任务参数，每个任务有三个参数：请求时间，运行时间，相对截止时间

然后把相对截止时间加上请求时间得出绝对截止时间。

每次进行调度时，找到当前看所有未完成并且已经请求的任务里绝对截止时间最小的分配资源并运行

这里要求“已经请求”的原因是，我们是虚拟的已知所有请求，但其实由于EDF是实时调度算法，现实中不可能提前知道有请求

所以请求时间晚的不应该参与到此处的比较。

这里没有对算法进行优化，这个算法里EDF每次调度都是O(n)的，如果考虑可以占用额外的内存情况下可以使用最小堆来进行调度
这样每次调度时间是O(logn)的
为了保证程序正常运行，要求所有数字为整数，这样做的原因是，当没有任务调度时，处理机应该是处于sleep的状态，这里我们默认每1秒检查一次
有没有可以调度的任务

测试用例
===================
见input.txt
```
5
0 5 50
2 20 50
0 20 40
20 1 10
21 1 10

```

这里给出了五个任务，从人工来看，会首先运行任务2，任务2运行完刚好任务3到达，再执行任务3，任务3完成后
任务4刚好到达，再进行任务4，最后执行任务0和1。

运行结果
===================
```
Execution trace:
  [ time   0 ] Run job 2 for 20.00 secs ( DONE at 20.00 )
  [ time   20 ] Run job 3 for 1.00 secs ( DONE at 21.00 )
  [ time   21 ] Run job 4 for 1.00 secs ( DONE at 22.00 )
  [ time   22 ] Run job 0 for 5.00 secs ( DONE at 27.00 )
  [ time   27 ] Run job 1 for 20.00 secs ( DONE at 47.00 )
Final statistics:
Job   2 -- Response: 0.00  Turnaround 20.00  Wait 0.00
Job   3 -- Response: 0.00  Turnaround 1.00  Wait 0.00
Job   4 -- Response: 0.00  Turnaround 1.00  Wait 0.00
Job   0 -- Response: 22.00  Turnaround 27.00  Wait 22.00
Job   1 -- Response: 25.00  Turnaround 45.00  Wait 25.00
  Average -- Response: 9.40  Turnaround 18.80  Wait 9.40
```

结果分析
===================
从上述情况来看运行结果应该是正确的。
我们可以看到任务绝对截止时间较长的可能会等待比较长，而后来的任务截止时间较短的会抢先运行，基本符合EDF的设计思想
也比较符合部分人的写作业方法（包括我），就是赶deadline的形式
